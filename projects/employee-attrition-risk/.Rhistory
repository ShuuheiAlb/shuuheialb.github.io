paste("x:", hr[1, ][c("AttritionProb_Year1", "")])
paste("x:", hr[1, ][c("AttritionProb_Year1")])
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
model = model_v2
save(list = c(hr, model), file = "Rdata.Rdata")
model <- model_v2
save(list = c(hr, model), file = "Rdata.Rdata")
saveRDS(model_v2, "model.rds")
saveRDS(hr, "transformed_data.rds")
runApp()
runApp()
runApp()
runApp()
runApp()
q
runApp()
runApp()
runApp()
for (i in 1:nrow(hridv)) {
lines(1:ncol(hridv), hridv[i, ], col = i, type = "l")
}
# Import & clean
setwd("Downloads/shuuheialb.github.io/projects/employee-attrition")
rm(list = ls())
hr <- read.csv("hr_data.csv")
# Filter columns
cols <- names(hr)
cols <- cols[cols != "EmployeeNumber"]
single_value_cols <- names(hr)[sapply(hr, function (col) length(unique(col)) == 1)]
cols <- cols[!(cols %in% single_value_cols)]
# Convert column data types
cat_cols <- c("BusinessTravel", "Department", "EducationField", "JobRole")
hr[cat_cols] <- lapply(hr[cat_cols], factor)
bool_cols <- c("Attrition", "Gender", "MaritalStatus", "OverTime")
hr[bool_cols] <- lapply(hr[bool_cols], function (col) ifelse(col == "Yes", TRUE, FALSE))
# Removing outliers
outlier_index <- function(df, col) {
vec <- df[[col]]
qnt <- quantile(vec, probs = c(0.25, 0.75))
iqr <- qnt[2] - qnt[1]
min <- qnt[1] - 3 * iqr
max <- qnt[2] + 3 * iqr
return(which(vec < min | vec > max))
}
hr_full_row <- hr
hr <- hr_full_row[-outlier_index(hr_full_row, "YearsAtCompany"), ]
library(survival)
library(randomForestSRC)
library(pec, warn.conflicts = FALSE)
library(ggplot2)
library(reshape2)
library(viridis)
# Models
coxph_model <- function (df) {
model <- coxph(data = df, formula = Surv(YearsAtCompany, Attrition) ~ ., method = "breslow", x = TRUE)
return(model)
}
rsf_model <- function (df) {
model <- rfsrc(Surv(YearsAtCompany, Attrition) ~ ., data = df, ntree = 100)
return(model)
}
# Cross-validation functions
train_test_generate <- function (df, proportion = 0.7) {
size <- round(proportion * nrow(df))
idx <- sample(seq_len(nrow(df)), size = size, replace = FALSE)
return(list("train" = df[idx, ], "test" = df[-idx, ]))
}
cross_val <- function (df, model_f, metric_f, k = 20) {
for (fold in 1:k) {
separate <- train_test_generate(df)
train <- separate$train
test <- separate$test
model <- model_f(train)
if (!(exists("metric_tot"))) {
metric_tot <- metric_f(test, model)
} else {
metric_tot <- metric_tot + metric_f(test, model)
}
}
metric_avg <- metric_tot/k
return(metric_avg[order(abs(metric_avg), decreasing = TRUE)])
}
# Validation metrics
# 1. Feature rank
# ----- Cox score
coxph_score <- function (df, model) {
return(summary(model)$coefficients[, "z"]) # the test data is indeed not used
}
print_coxph_var_rank <- function (df) {
print("Average univariate Cox score:")
print(cross_val(df, coxph_model, coxph_score))
}
coxph_slope <- function (df, model) {
return(summary(model)$coefficients[, "coef"])
}
# ----- Importance
rsf_importance <- function (df, model) {
importance <- predict(model, df, importance = TRUE)$importance
return(importance)
}
print_rsf_var_rank <- function (df) {
print("Average variable importance:")
print(cross_val(df, rsf_model, rsf_importance))
}
# 2. C-index
print_c_index <- function(df, model_f) {
print("Average concordance index:")
print(cross_val(df, model_f, function (sub_df, model) {
unlist(cindex(model, formula = Surv(YearsAtCompany, Attrition) ~ ., data = sub_df)$AppCindex)
}))
}
print_coxph_var_rank <- function (df, k = 20) {
print("Average univariate Cox score:")
print(cross_val(df, coxph_model, coxph_score, k))
}
# 3. PEC
plot_pec <- function(df, model_f) {
suppressMessages(pred_error <- pec(model_f(df), data = df, formula = Surv(YearsAtCompany, Attrition) ~ .,
splitMethod = "cv10", cens.model = "marginal", reference = FALSE))
plot(pred_error, xlim = c(0, 10), ylim = c(0, 0.25)) # 0.25 is the worst case scenario (random model)
title("Prediction Error Curve")
}
# Assumption functions
check_proportional_hazard <- function(model) {
print(cox.zph(model))
}
plot_correlation <- function (df, limit = -1) {
# Only numerical (unless categories can be continuously extended)
num_cols <- sapply(df, is.numeric)
bool_cols <- sapply(df, is.logical)
df2 <- df[, num_cols | bool_cols]
# Only select the high-correlated columns
cor_matrix <- cor(df2)
high_cor_pairs <- which(cor_matrix >= limit & cor_matrix < 1, arr.ind = TRUE)
high_cor_cols <- colnames(df2)[high_cor_pairs[, 1]]
ggplot(data = melt(cor_matrix[high_cor_cols, high_cor_cols]), aes(x = Var1, y = Var2, fill = value)) +
geom_tile() + scale_fill_viridis() +
xlab("") + ylab("") + ggtitle("Correlation Map") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
plot.title = element_text(hjust = 0.5))
}
# First iteration
#hr1 <- hr[cols]
#model_v1 <- rsf_model(hr1)
#plot_pec(hr1, model_v1)
#k_fold_cross_val(hr1)
# Final iteration
rsf_cols <- c("Attrition", "YearsAtCompany", "JobLevel", "OverTime", "StockOptionLevel",
"JobRole", "EnvironmentSatisfaction", "NotWorkingYears")
coxph_cols <- c("Attrition", "YearsAtCompany", "OverTime", "JobInvolvement", "DistanceFromHome",
"JobSatisfaction", "BusinessTravel", "EnvironmentSatisfaction", "MaritalStatus",
"Gender")
rsf_final_model <- rsf_model(hr[rsf_cols])
# Filter columns
cols <- names(hr)
cols <- cols[cols != "EmployeeNumber"]
single_value_cols <- names(hr)[sapply(hr, function (col) length(unique(col)) == 1)]
cols <- cols[!(cols %in% single_value_cols)]
# Convert column data types
cat_cols <- c("BusinessTravel", "Department", "EducationField", "JobRole")
hr[cat_cols] <- lapply(hr[cat_cols], factor)
bool_cols <- c("Attrition", "Gender", "MaritalStatus", "OverTime")
hr[bool_cols] <- lapply(hr[bool_cols], function (col) ifelse(col == "Yes", TRUE, FALSE))
# Removing outliers
outlier_index <- function(df, col) {
vec <- df[[col]]
qnt <- quantile(vec, probs = c(0.25, 0.75))
iqr <- qnt[2] - qnt[1]
min <- qnt[1] - 3 * iqr
max <- qnt[2] + 3 * iqr
return(which(vec < min | vec > max))
}
hr_train <- hr[-outlier_index(hr_full_row, "YearsAtCompany"), ]
hr["NotWorkingYears"] <- hr["Age"] - hr["TotalWorkingYears"]
hr["YearsAtOtherCompanies"] <- hr["TotalWorkingYears"] - hr["YearsAtCompany"]
library(survival)
library(randomForestSRC)
library(pec, warn.conflicts = FALSE)
library(ggplot2)
library(reshape2)
library(viridis)
# Models
coxph_model <- function (df) {
model <- coxph(data = df, formula = Surv(YearsAtCompany, Attrition) ~ ., method = "breslow", x = TRUE)
return(model)
}
rsf_model <- function (df) {
model <- rfsrc(Surv(YearsAtCompany, Attrition) ~ ., data = df, ntree = 100)
return(model)
}
# Cross-validation functions
train_test_generate <- function (df, proportion = 0.7) {
size <- round(proportion * nrow(df))
idx <- sample(seq_len(nrow(df)), size = size, replace = FALSE)
return(list("train" = df[idx, ], "test" = df[-idx, ]))
}
cross_val <- function (df, model_f, metric_f, k = 20) {
for (fold in 1:k) {
separate <- train_test_generate(df)
train <- separate$train
test <- separate$test
model <- model_f(train)
if (!(exists("metric_tot"))) {
metric_tot <- metric_f(test, model)
} else {
metric_tot <- metric_tot + metric_f(test, model)
}
}
metric_avg <- metric_tot/k
return(metric_avg[order(abs(metric_avg), decreasing = TRUE)])
}
# Validation metrics
# 1. Feature rank
# ----- Cox score
coxph_score <- function (df, model) {
return(summary(model)$coefficients[, "z"]) # the test data is indeed not used
}
print_coxph_var_rank <- function (df) {
print("Average univariate Cox score:")
print(cross_val(df, coxph_model, coxph_score))
}
coxph_slope <- function (df, model) {
return(summary(model)$coefficients[, "coef"])
}
# ----- Importance
rsf_importance <- function (df, model) {
importance <- predict(model, df, importance = TRUE)$importance
return(importance)
}
print_rsf_var_rank <- function (df) {
print("Average variable importance:")
print(cross_val(df, rsf_model, rsf_importance))
}
# 2. C-index
print_c_index <- function(df, model_f) {
print("Average concordance index:")
print(cross_val(df, model_f, function (sub_df, model) {
unlist(cindex(model, formula = Surv(YearsAtCompany, Attrition) ~ ., data = sub_df)$AppCindex)
}))
}
print_coxph_var_rank <- function (df, k = 20) {
print("Average univariate Cox score:")
print(cross_val(df, coxph_model, coxph_score, k))
}
# 3. PEC
plot_pec <- function(df, model_f) {
suppressMessages(pred_error <- pec(model_f(df), data = df, formula = Surv(YearsAtCompany, Attrition) ~ .,
splitMethod = "cv10", cens.model = "marginal", reference = FALSE))
plot(pred_error, xlim = c(0, 10), ylim = c(0, 0.25)) # 0.25 is the worst case scenario (random model)
title("Prediction Error Curve")
}
# Assumption functions
check_proportional_hazard <- function(model) {
print(cox.zph(model))
}
plot_correlation <- function (df, limit = -1) {
# Only numerical (unless categories can be continuously extended)
num_cols <- sapply(df, is.numeric)
bool_cols <- sapply(df, is.logical)
df2 <- df[, num_cols | bool_cols]
# Only select the high-correlated columns
cor_matrix <- cor(df2)
high_cor_pairs <- which(cor_matrix >= limit & cor_matrix < 1, arr.ind = TRUE)
high_cor_cols <- colnames(df2)[high_cor_pairs[, 1]]
ggplot(data = melt(cor_matrix[high_cor_cols, high_cor_cols]), aes(x = Var1, y = Var2, fill = value)) +
geom_tile() + scale_fill_viridis() +
xlab("") + ylab("") + ggtitle("Correlation Map") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
plot.title = element_text(hjust = 0.5))
}
# Final iteration
rsf_cols <- c("Attrition", "YearsAtCompany", "JobLevel", "OverTime", "StockOptionLevel",
"JobRole", "EnvironmentSatisfaction", "NotWorkingYears")
coxph_cols <- c("Attrition", "YearsAtCompany", "OverTime", "JobInvolvement", "DistanceFromHome",
"JobSatisfaction", "BusinessTravel", "EnvironmentSatisfaction", "MaritalStatus",
"Gender")
rsf_final_model <- rsf_model(hr[rsf_cols])
rm(list = ls())
hr <- read.csv("hr_data.csv")
# Filter columns
cols <- names(hr)
cols <- cols[cols != "EmployeeNumber"]
single_value_cols <- names(hr)[sapply(hr, function (col) length(unique(col)) == 1)]
cols <- cols[!(cols %in% single_value_cols)]
# Convert column data types
cat_cols <- c("BusinessTravel", "Department", "EducationField", "JobRole")
hr[cat_cols] <- lapply(hr[cat_cols], factor)
bool_cols <- c("Attrition", "Gender", "MaritalStatus", "OverTime")
hr[bool_cols] <- lapply(hr[bool_cols], function (col) ifelse(col == "Yes", TRUE, FALSE))
# Adding columns
hr["NotWorkingYears"] <- hr["Age"] - hr["TotalWorkingYears"]
hr["YearsAtOtherCompanies"] <- hr["TotalWorkingYears"] - hr["YearsAtCompany"]
# Removing outliers
outlier_index <- function(df, col) {
vec <- df[[col]]
qnt <- quantile(vec, probs = c(0.25, 0.75))
iqr <- qnt[2] - qnt[1]
min <- qnt[1] - 3 * iqr
max <- qnt[2] + 3 * iqr
return(which(vec < min | vec > max))
}
hr_train <- hr[-outlier_index(hr, "YearsAtCompany"), ]
library(survival)
library(randomForestSRC)
library(pec, warn.conflicts = FALSE)
library(ggplot2)
library(reshape2)
library(viridis)
# Models
coxph_model <- function (df) {
model <- coxph(data = df, formula = Surv(YearsAtCompany, Attrition) ~ ., method = "breslow", x = TRUE)
return(model)
}
rsf_model <- function (df) {
model <- rfsrc(Surv(YearsAtCompany, Attrition) ~ ., data = df, ntree = 100)
return(model)
}
# Cross-validation functions
train_test_generate <- function (df, proportion = 0.7) {
size <- round(proportion * nrow(df))
idx <- sample(seq_len(nrow(df)), size = size, replace = FALSE)
return(list("train" = df[idx, ], "test" = df[-idx, ]))
}
cross_val <- function (df, model_f, metric_f, k = 20) {
for (fold in 1:k) {
separate <- train_test_generate(df)
train <- separate$train
test <- separate$test
model <- model_f(train)
if (!(exists("metric_tot"))) {
metric_tot <- metric_f(test, model)
} else {
metric_tot <- metric_tot + metric_f(test, model)
}
}
metric_avg <- metric_tot/k
return(metric_avg[order(abs(metric_avg), decreasing = TRUE)])
}
# Validation metrics
# 1. Feature rank
# ----- Cox score
coxph_score <- function (df, model) {
return(summary(model)$coefficients[, "z"]) # the test data is indeed not used
}
print_coxph_var_rank <- function (df) {
print("Average univariate Cox score:")
print(cross_val(df, coxph_model, coxph_score))
}
coxph_slope <- function (df, model) {
return(summary(model)$coefficients[, "coef"])
}
# ----- Importance
rsf_importance <- function (df, model) {
importance <- predict(model, df, importance = TRUE)$importance
return(importance)
}
print_rsf_var_rank <- function (df) {
print("Average variable importance:")
print(cross_val(df, rsf_model, rsf_importance))
}
# 2. C-index
print_c_index <- function(df, model_f) {
print("Average concordance index:")
print(cross_val(df, model_f, function (sub_df, model) {
unlist(cindex(model, formula = Surv(YearsAtCompany, Attrition) ~ ., data = sub_df)$AppCindex)
}))
}
print_coxph_var_rank <- function (df, k = 20) {
print("Average univariate Cox score:")
print(cross_val(df, coxph_model, coxph_score, k))
}
# 3. PEC
plot_pec <- function(df, model_f) {
suppressMessages(pred_error <- pec(model_f(df), data = df, formula = Surv(YearsAtCompany, Attrition) ~ .,
splitMethod = "cv10", cens.model = "marginal", reference = FALSE))
plot(pred_error, xlim = c(0, 10), ylim = c(0, 0.25)) # 0.25 is the worst case scenario (random model)
title("Prediction Error Curve")
}
# Assumption functions
check_proportional_hazard <- function(model) {
print(cox.zph(model))
}
plot_correlation <- function (df, limit = -1) {
# Only numerical (unless categories can be continuously extended)
num_cols <- sapply(df, is.numeric)
bool_cols <- sapply(df, is.logical)
df2 <- df[, num_cols | bool_cols]
# Only select the high-correlated columns
cor_matrix <- cor(df2)
high_cor_pairs <- which(cor_matrix >= limit & cor_matrix < 1, arr.ind = TRUE)
high_cor_cols <- colnames(df2)[high_cor_pairs[, 1]]
ggplot(data = melt(cor_matrix[high_cor_cols, high_cor_cols]), aes(x = Var1, y = Var2, fill = value)) +
geom_tile() + scale_fill_viridis() +
xlab("") + ylab("") + ggtitle("Correlation Map") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
plot.title = element_text(hjust = 0.5))
}
# Final iteration
rsf_cols <- c("Attrition", "YearsAtCompany", "JobLevel", "OverTime", "StockOptionLevel",
"JobRole", "EnvironmentSatisfaction", "NotWorkingYears")
coxph_cols <- c("Attrition", "YearsAtCompany", "OverTime", "JobInvolvement", "DistanceFromHome",
"JobSatisfaction", "BusinessTravel", "EnvironmentSatisfaction", "MaritalStatus",
"Gender")
rsf_final_model <- rsf_model(hr[rsf_cols])
coxph_final_model <- coxph_model(hr[coxph_cols])
cols <- c("Attrition", "YearsAtCompany", "MonthlyIncome", "OverTime", "Age",
"JobRole", "NumCompaniesWorkedPerYear", "StockOptionLevel")
hr["HazardRatio_CoxPH"] <- predict(coxph_final_model, type = "risk")
hr["Hazard_RSF"] <- predict(rsf_final_model, hr)$chf[, 1]
hr["Hazard_CoxPH"] <- ( as.matrix(exp(predict(coxph_final_model, type = "lp"))) %*%
t(as.matrix(basehaz(coxph_final_model)["hazard"])) )[, 1]
rsf_attrition_prob <- function (df, model) {
return(predict(model, df)$chf)
}
for (i in 1:5) {
hr[, paste0("AttritionProb_Year", i)] <- rsf_attrition_prob(hr, rsf_final_model)[, i+1]
}
head(hr)
hriidx <- rsf_high_risk_indiv_idx(hr, rsf_final_model)
cutoff = 50
sorted <- function (df, key_col) {
df <- df[df["Attrition"] == FALSE, ]
return(row.names(df)[order(df[, key_col], decreasing = TRUE)][1:cutoff])
}
rsf_attrition_prob <- function (df, model) {
return(predict(model, df)$chf)
}
for (i in 1:5) {
hr[, paste0("AttritionProb_Year", i)] <- rsf_attrition_prob(hr, rsf_final_model)[, i+1]
}
head(hr)
hridv <- hr[sorted(hr, "HazardRatio_CoxPH"), preview_cols]
preview_cols <- c("EmployeeNumber", coxph_cols, rsf_cols, "HazardRatio_CoxPH", "Hazard_CoxPH", "Hazard_RSF")
hridv <- hr[sorted(hr, "HazardRatio_CoxPH"), preview_cols]
plot(1, type = "n", xlim = c(0, 5), ylim = (0, 1), xlab = "Year", ylab = "Probability")
plot(1, type = "n", xlim = c(0, 5), ylim = c(0, 1), xlab = "Year", ylab = "Probability")
title("100 High-Risk Employee Turnoever Trajectory")
for (i in 1:cutoff) {
lines(0:years, hridv[i, paste0("AttritionProb_Year", i)], col = i, type = "l")
}
title("100 High-Risk Employee Turnoever Trajectory")
for (i in 1:cutoff) {
lines(0:5, hridv[i, paste0("AttritionProb_Year", i)], col = i, type = "l")
}
legend("topright", legend = hridv[, "EmployeeNumber"], col = 1:nrow(hridv), lty = 1, title = "Employee Number")
rsf_attrition_prob <- function (df, model) {
return(1 - predict(model, df)$survival)
}
for (i in 1:5) {
hr[, paste0("AttritionProb_Year", i)] <- rsf_attrition_prob(hr, rsf_final_model)[, i+1]
}
head(hr)
preview_cols <- c("EmployeeNumber", coxph_cols, rsf_cols, "HazardRatio_CoxPH", "Hazard_CoxPH", "Hazard_RSF")
hridv <- hr[sorted(hr, "HazardRatio_CoxPH"), preview_cols]
plot(1, type = "n", xlim = c(0, 5), ylim = c(0, 1), xlab = "Year", ylab = "Probability")
title("100 High-Risk Employee Turnoever Trajectory")
for (i in 1:cutoff) {
lines(0:5, hridv[i, paste0("AttritionProb_Year", i)], col = i, type = "l")
}
legend("topright", legend = hridv[, "EmployeeNumber"], col = 1:nrow(hridv), lty = 1, title = "Employee Number")
ap_cols = sapply(1:5, function(i) paste0("AttritionProb_Year", i))
for (i in 1:5) {
hr[, paste0("AttritionProb_Year", i)] <- rsf_attrition_prob(hr, rsf_final_model)[, i+1]
}
head(hr)
preview_cols <- c("EmployeeNumber", ap_cols, coxph_cols, rsf_cols,
"HazardRatio_CoxPH", "Hazard_CoxPH", "Hazard_RSF")
hridv <- hr[sorted(hr, "HazardRatio_CoxPH"), preview_cols]
plot(1, type = "n", xlim = c(0, 5), ylim = c(0, 1), xlab = "Year", ylab = "Probability")
title("100 High-Risk Employee Turnoever Trajectory")
for (i in 1:cutoff) {
lines(0:5, hridv[i, paste0("AttritionProb_Year", i)], col = i, type = "l")
}
View(hridv)
ap_cols = sapply(0:5, function(i) paste0("AttritionProb_Year", i))
for (i in 0:5) {
hr[, paste0("AttritionProb_Year", i)] <- rsf_attrition_prob(hr, rsf_final_model)[, i+1]
}
head(hr)
preview_cols <- c("EmployeeNumber", ap_cols, coxph_cols, rsf_cols,
"HazardRatio_CoxPH", "Hazard_CoxPH", "Hazard_RSF")
hridv <- hr[sorted(hr, "HazardRatio_CoxPH"), preview_cols]
plot(1, type = "n", xlim = c(0, 5), ylim = c(0, 1), xlab = "Year", ylab = "Probability")
title("100 High-Risk Employee Turnoever Trajectory")
for (i in 1:cutoff) {
lines(0:5, hridv[i, paste0("AttritionProb_Year", i)], col = i, type = "l")
}
for (i in 1:cutoff) {
lines(0:5, hridv[i, ap_cols], col = i, type = "l")
}
legend("topright", legend = hridv[, "EmployeeNumber"], col = 1:nrow(hridv), lty = 1, title = "Employee Number")
preview_cols <- c("EmployeeNumber", ap_cols, coxph_cols, rsf_cols,
"HazardRatio_CoxPH", "Hazard_CoxPH", "Hazard_RSF")
hridv <- hr[sorted(hr, "Hazard_RSF"), preview_cols]
plot(1, type = "n", xlim = c(0, 5), ylim = c(0, 1), xlab = "Year", ylab = "Probability")
title("100 High-Risk Employee Turnoever Trajectory")
for (i in 1:cutoff) {
lines(0:5, hridv[i, ap_cols], col = i, type = "l")
}
legend("topright", legend = hridv[, "EmployeeNumber"], col = 1:nrow(hridv), lty = 1, title = "Employee Number")
install.packages("plotly")
